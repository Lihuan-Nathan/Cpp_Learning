1.数组作为参数传递进来，本质就是一个指针，如果算数组长度的时候，这个时候的数组名就是一个指针而不是代表整个数组，sizeof(函数名)其实就是算出一个指针的的内存大小，不是整个数组的内存大小，所以这个时候使用sizeof(函数名)/sizeof(arr[0]) 算不是数组的长度。
2.空指针：指针指向地址编号为0的指针；用途：指针变量初始化；空指针是不可访问的
3.野指针：指针变量指向非法地址空间。
4.5.6可看自己博客
4.指针常量： int* const p(按照英文顺序往过翻译:1.int*代表指针；2.const p代表常量，所以叫指针常量；const加到常量前，说明指针指向的内容不能变)
5.常量指针： const int* p(按照英文顺序往过翻译:1.const 代表常量；2.int* p代表指针，所以叫常量指针。const加到整个指针前面了，所以指针的指向不能变)
6.const int* const p (指针指向的值和指针指向的地址都不能变)
7.extern 的用法：extern就是将外部的声明的变量函数引用进来，文件1中将定义全局变量a,定义函数fn;文件2中在变量的声明前面加extern,在函数的声明前也加extern,将文件1中定义的全局变量和方法就可以引入到本文件中。
8.static 的用法：存储时候和全局变量一样是存储在堆上，生命周期是从开始定义定义到整个程序的结束，作用2：将变量限制在本作用域，如果是全局变量(或者函数)，就限制在本源文件，不允许extern.
9 内存四区：
	c++程序在运行时，将内存大分为4个区域。
	代码区：存放函数体的二进制代码，由操作系统进行管理。（共享、只读）
	全局区：存放全局变量和静态变量以及常量，（该区域数据在程序结束后由操作体系统释放）
	栈区：由编译器自动分配释放、存放函数的参数、局部变量
	堆区：由程序员分配和释放，若程序员不释放，程序结束时系统自动回收。


10.类型名* p = new 一个对象 new 类型名（）           delete  p
   类型名* arr = new 一组对象 new 类型名[长度]       delete  []arr   如果类型为简单类型（如int,也可使用delete arr）,如果为自定义的类名直接使用必须使用delete []arr，如果使用delete arr，仅释放了arr指针指向的全部内存空间但是只调用了arr[0]对象的析构函数 剩下的从arr[1]到arr[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放,从而造成内存泄漏.
11.什么叫内存泄漏：内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
12.引用：给变量起别名；语法： 数据类型& 别名 = 原名   注意：引用必须初始化、引用一但初始化就不可在变。
13.引用的本质：指针常量，所以引用必须初始化，而且初始化后不能改变（详细见博客代码），引用可以节省内存。
14.函数形参一旦赋值后，该形参后面的参数必须都得赋值。
15.函数重载：1.在同一作用域下；2.函数名相同；3.函数参数个数不同或者个数不同或者不同类型的参数顺序不同。（注意：形参名字不能做为判断依据，返回值类型也不能作为函数重载的依据）
16.类的访问权限：public: 类内可以访问，类外可以访问；protect:类内可以访问，类外不能访问；private:类内可以访问，类外不能访问。 类内（是指的是类的作用域大括号范围内）
17.类的默认的访问权限是私有的（private），struct的默认访问权限是公开(public)。
18.操作类的私有属性，可以通过类的方法去get或者set。
19.深拷贝:
20.浅拷贝:
21.类中嵌套对象：
21.静态成员函数：可以访问静态成员变量，不可以访问非静态成员变量。静态成员函数也是有访问权限的。
22.空类的大小：C++编译器会给每个空对象分配一个字节的空间，是为了区分空对象占内存的位置，每个空对象也应该有一个独一无的内存地址。
23.成员变量和成员函数是分开存储的
24.this指针。1.解决命名冲突，2.*this返回对象本身。3.this指针是可以调用成员函数的。Person *p = NULL; p->test();只要是test方法中没有使用到成员变量就可以调用成功。
25.this指针的本质是指针常量， 指针的指向是不可以修改的。
25.const修饰成员函数：void show()const  在成员函数后面加const修饰的是this指针，让指针指向的值也不可以修改。
26.常对象 const Person p; //在对象前面加const,变为常对象，常对象只能调用常函数，因为不是常函数，可能会修改成员变量。
27.如果成员变量用mutable修饰的时候， 能去掉const常函数和常变量不能修改的约束。
28.友元：友元的目的就是让一个函数或者类 访问另一个类中私有成员。友元分为3种，友元全局函数，类做友元，成员函数做友元
29 友元全局函数：如果全局函数声名为该类的友元函数，则该全局函数就可以访问该类的私有属性，声明为该类的友元函数的方法为在该类的内部声明函数，并在函数加上friend关键字
30.友元类：
31.另外一个类的成员函数做友元：
32.运算符重载 成员函数方式、全局函数重载
33.继承方式
34.父类中所有非静态成员属性都会被子类继承下去，
   父类中的私有成员属性是被编译器给隐藏了，因此访问不到，但是确实被继承下去了，测试子类的内存大小的时候会发现，父类中的所有属性都在子类中。
35.利用开发人员命令提示工具查看对象模型： cl /d1 reportSingleClassLayout类名 文件名
36.子类构造的时候会先调用父类的构造函数、析构顺序相反
38.访问父类同名成员属性   1.访问子类同名成员   直接访问即可               2.访问父类同名成员   需要加作用域
39.访问父类同名成员方法，如果子类中出现和父类相同的成员方法（只要名字相同，不管参数）
   这个时候直接访问的话，访问的是子类的方法，如果要访问父类的方法，就必须加作用域。
40.